---
title: "Hands on R programming part 3"
output: html_notebook
---

9 Programs
generate symbols
```{r}
get_symbols <- function() {
  wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size = 3, replace = TRUE, 
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
}

get_symbols()
get_symbols()
get_symbols()

```

9.1 Strategy
Break complex tasks into simple subtasks.
Use concrete examples.
Describe your solutions in English, then convert them to R.

R programs contain two types of subtasks: sequential steps and parallel cases.

9.1.1 Sequential Steps
One way to subdivide a program is into a series of sequential steps. The play function takes the approach, shown in Figure 9.1. First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3):
```{r}
play <- function() {

  # step 1: generate symbols
  symbols <- get_symbols()

  # step 2: display the symbols
  print(symbols)

  # step 3: score the symbols
  score(symbols)
}
```

9.1.2 Parallel Cases
Another way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time.

9.2 if Statements
An if statement tells R to do a certain task for a certain case. In English you would say something like, “If this is true, do that.” In R, you would say:
`
```{r}
num <- -2

if (num < 0) {
  num <- num * -1
}

num

num <- 4

if (num < 0) {
  num <- num * -1
}

num
```

```{r}
num <- -1

if (num < 0) {
  print("num is negative.")
  print("Don't worry, I'll fix it.")
  num <- num * -1
  print("Now num is positive.")
}
num
```

9.3 else Statements
else is a counterpart to if that extends an if statement to include a second case. In English, you would say, “If this is true, do plan A; else do plan B.” 
```{r}
a <- 3.14
dec <- a - trunc(a)
dec

if (dec >= 0.5) {
  a <- trunc(a) + 1
} else {
  a <- trunc(a)
}

a
```

```{r}
a <- 1
b <- 1

if (a > b) {
  print("A wins!")
} else if (a < b) {
  print("B wins!")
} else {
  print("Tie.")
}
```

You can use if and else to link the subtasks in your slot-machine function.
```{r}
if ( # Case 1: all the same <1>) {
  prize <- # look up the prize <3>
} else if ( # Case 2: all bars <2> ) {
  prize <- # assign $5 <4>
} else {
  # count cherries <5>
  prize <- # calculate a prize <7>
}

# count diamonds <6>
# double the prize if necessary <8>
```

Our skeleton is rather incomplete; there are many sections that are just code comments instead of real code. However, we’ve reduced the program to eight simple subtasks:

<1> - Test whether the symbols are three of a kind.
<2> - Test whether the symbols are all bars.
<3> - Look up the prize for three of a kind based on the common symbol.
<4> - Assign a prize of $5.
<5> - Count the number of cherries.
<6> - Count the number of diamonds.
<7> - Calculate a prize based on the number of cherries.
<8> - Adjust the prize for diamonds.

As your vocabulary of R functions broadens, you’ll think of more ways to do basic tasks. One method that I like for checking three of a kind is:
```{r}
length(unique(symbols) == 1)

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]

if (same) {
  prize <- # look up the prize
} else if ( # Case 2: all bars ) {
  prize <- # assign $5
} else {
  # count cherries
  prize <- # calculate a prize
}

# count diamonds
# double the prize if necessary
```

check for bars
```{r}
all(symbols %in% c("B", "BB", "BBB"))

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

if (same) {
  prize <- # look up the prize
} else if (all(bars)) {
  prize <- # assign $5
} else {
  # count cherries
  prize <- # calculate a prize
}

# count diamonds
# double the prize if necessary
```

9.4 Lookup Tables
This vector can store symbols as names and prize values as elements:
```{r}
payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
  "B" = 10, "C" = 10, "0" = 0)
payouts

payouts["DD"]

payouts["B"]
```
unname returns a copy of an object with the names attribute removed.

payouts is a type of lookup table, an R object that you can use to look up values. Subsetting payouts provides a simple way to find the prize for a symbol.

finding payout without know specific symbol
```{r}
symbols <- c("C", "C", "C")
payouts[symbols[1]]
```

```{r}
symbols <- c("C", "DD", "C")
sum(symbols == "C")
sum(symbols == "DD")

```

```{r}
same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
    "B" = 10, "C" = 10, "0" = 0)
  prize <- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize <- 5
} else {
  # count cherries
  cherries <-sum(symbols == "C")
  prize <- c(0, 2, 5)[cherries + 1]
}

# count diamonds
diamonds <- sum(symbols == "DD")
# double the prize if necessary
prize * 2 ^ diamonds
```


9.5 Code Comments

```{r}
# identify case
same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

# get prize
if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
    "B" = 10, "C" = 10, "0" = 0)
  prize <- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize <- 5
} else {
  cherries <- sum(symbols == "C")
  prize <- c(0, 2, 5)[cherries + 1]
}

# adjust for diamonds
diamonds <- sum(symbols == "DD")
prize * 2 ^ diamonds
```

get symbols function
```{r}
get_symbols <- function() {
  wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size = 3, replace = TRUE, 
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
}
```


score function
```{r}
score <- function (symbols) {
  # identify case
  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
  bars <- symbols %in% c("B", "BB", "BBB")
  
  # get prize
  if (same) {
    payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
      "B" = 10, "C" = 10, "0" = 0)
    prize <- unname(payouts[symbols[1]])
  } else if (all(bars)) {
    prize <- 5
  } else {
    cherries <- sum(symbols == "C")
    prize <- c(0, 2, 5)[cherries + 1]
  }
  
  # adjust for diamonds
  diamonds <- sum(symbols == "DD")
  prize * 2 ^ diamonds
}
```

now we can define play function
```{r}
play <- function() {
  symbols <- get_symbols()
  print(symbols)
  score(symbols)
}

play()
play()
```

10.1 The S3 System
S3 refers to a class system built into R. The system governs how R handles objects of different classes. Certain R functions will look up an object’s S3 class, and then behave differently in response.

```{r}
num <- 1000000000
print(num)
## 1000000000

class(num) <- c("POSIXct", "POSIXt")
print(num)
## "2001-09-08 19:46:40 CST"
```

If you use objects with classes—and you do—you will run into R’s S3 system. S3 behavior can seem odd at first, but is easy to predict once you are familiar with it.

R’s S3 system is built around three components: attributes (especially the class attribute), generic functions, and methods.

10.2 Attributes
Exercise 10.1 (Add an Attribute) Modify play to return a prize that contains the symbols associated with it as an attribute named symbols. Remove the redundant call to print(symbols):
```{r}
play <- function() {
  symbols <- get_symbols()
  prize <- score(symbols)
  attr(prize, "symbols") <- symbols
  prize
}
```

10.3 Generic Functions
R uses print more often than you may think; R calls print each time it displays a result in your console window. This call happens in the background, so you do not notice it; but the call explains how output makes it to the console window (recall that print always prints its argument in the console window). This print call also explains why the output of print always matches what you see when you display an object at the command line:


10.4 Methods
You can see which methods exist for a generic function by calling methods on the function. For example, print has almost 200 methods (which gives you an idea of how many classes exist in R):
```{r}
methods(print)

```
10.4.1 Method Dispatch
UseMethod uses a very simple system to match methods to functions.

Every S3 method has a two-part name. The first part of the name will refer to the function that the method works with. The second part will refer to the class. These two parts will be separated by a period.

11. Loops
11.2 expand.grid
The expand.grid function in R provides a quick way to write out every combination of the elements in n vectors. For example, you can list every combination of two dice. To do so, run expand.grid on two copies of die
```{r}
rolls <- expand.grid(die, die)
rolls

rolls$value <- rolls$Var1 + rolls$Var2
head(rolls, 3)
```

